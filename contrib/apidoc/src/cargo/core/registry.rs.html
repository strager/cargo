<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/cargo/core/registry.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>registry.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../../cargo/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
</pre><pre class="rust"><code><span class="kw">use </span>std::collections::{HashMap, HashSet};
<span class="kw">use </span>std::task::{ready, Poll};

<span class="kw">use </span><span class="kw">crate</span>::core::PackageSet;
<span class="kw">use </span><span class="kw">crate</span>::core::{Dependency, PackageId, QueryKind, Source, SourceId, SourceMap, Summary};
<span class="kw">use </span><span class="kw">crate</span>::sources::config::SourceConfigMap;
<span class="kw">use </span><span class="kw">crate</span>::util::errors::CargoResult;
<span class="kw">use </span><span class="kw">crate</span>::util::interning::InternedString;
<span class="kw">use </span><span class="kw">crate</span>::util::{CanonicalUrl, Config};
<span class="kw">use </span>anyhow::{bail, Context <span class="kw">as _</span>};
<span class="kw">use </span>log::{debug, trace};
<span class="kw">use </span>url::Url;

<span class="doccomment">/// Source of information about a group of packages.
///
/// See also `core::Source`.
</span><span class="kw">pub trait </span>Registry {
    <span class="doccomment">/// Attempt to find the packages that match a dependency request.
    </span><span class="kw">fn </span>query(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        dep: <span class="kw-2">&amp;</span>Dependency,
        kind: QueryKind,
        f: <span class="kw-2">&amp;mut </span><span class="kw">dyn </span>FnMut(Summary),
    ) -&gt; Poll&lt;CargoResult&lt;()&gt;&gt;;

    <span class="kw">fn </span>query_vec(<span class="kw-2">&amp;mut </span><span class="self">self</span>, dep: <span class="kw-2">&amp;</span>Dependency, kind: QueryKind) -&gt; Poll&lt;CargoResult&lt;Vec&lt;Summary&gt;&gt;&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>ret = Vec::new();
        <span class="self">self</span>.query(dep, kind, <span class="kw-2">&amp;mut </span>|s| ret.push(s)).map_ok(|()| ret)
    }

    <span class="kw">fn </span>describe_source(<span class="kw-2">&amp;</span><span class="self">self</span>, source: SourceId) -&gt; String;
    <span class="kw">fn </span>is_replaced(<span class="kw-2">&amp;</span><span class="self">self</span>, source: SourceId) -&gt; bool;

    <span class="doccomment">/// Block until all outstanding Poll::Pending requests are Poll::Ready.
    </span><span class="kw">fn </span>block_until_ready(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; CargoResult&lt;()&gt;;
}

<span class="doccomment">/// This structure represents a registry of known packages. It internally
/// contains a number of `Box&lt;Source&gt;` instances which are used to load a
/// `Package` from.
///
/// The resolution phase of Cargo uses this to drive knowledge about new
/// packages as well as querying for lists of new packages. It is here that
/// sources are updated (e.g., network operations) and overrides are
/// handled.
///
/// The general idea behind this registry is that it is centered around the
/// `SourceMap` structure, contained within which is a mapping of a `SourceId` to
/// a `Source`. Each `Source` in the map has been updated (using network
/// operations if necessary) and is ready to be queried for packages.
</span><span class="kw">pub struct </span>PackageRegistry&lt;<span class="lifetime">&#39;cfg</span>&gt; {
    config: <span class="kw-2">&amp;</span><span class="lifetime">&#39;cfg </span>Config,
    sources: SourceMap&lt;<span class="lifetime">&#39;cfg</span>&gt;,

    <span class="comment">// A list of sources which are considered &quot;overrides&quot; which take precedent
    // when querying for packages.
    </span>overrides: Vec&lt;SourceId&gt;,

    <span class="comment">// Note that each SourceId does not take into account its `precise` field
    // when hashing or testing for equality. When adding a new `SourceId`, we
    // want to avoid duplicates in the `SourceMap` (to prevent re-updating the
    // same git repo twice for example), but we also want to ensure that the
    // loaded source is always updated.
    //
    // Sources with a `precise` field normally don&#39;t need to be updated because
    // their contents are already on disk, but sources without a `precise` field
    // almost always need to be updated. If we have a cached `Source` for a
    // precise `SourceId`, then when we add a new `SourceId` that is not precise
    // we want to ensure that the underlying source is updated.
    //
    // This is basically a long-winded way of saying that we want to know
    // precisely what the keys of `sources` are, so this is a mapping of key to
    // what exactly the key is.
    </span>source_ids: HashMap&lt;SourceId, (SourceId, Kind)&gt;,

    locked: LockedMap,
    yanked_whitelist: HashSet&lt;PackageId&gt;,
    source_config: SourceConfigMap&lt;<span class="lifetime">&#39;cfg</span>&gt;,

    patches: HashMap&lt;CanonicalUrl, Vec&lt;Summary&gt;&gt;,
    patches_locked: bool,
    patches_available: HashMap&lt;CanonicalUrl, Vec&lt;PackageId&gt;&gt;,
}

<span class="doccomment">/// A map of all &quot;locked packages&quot; which is filled in when parsing a lock file
/// and is used to guide dependency resolution by altering summaries as they&#39;re
/// queried from this source.
///
/// This map can be thought of as a glorified `Vec&lt;MySummary&gt;` where `MySummary`
/// has a `PackageId` for which package it represents as well as a list of
/// `PackageId` for the resolved dependencies. The hash map is otherwise
/// structured though for easy access throughout this registry.
</span><span class="kw">type </span>LockedMap = HashMap&lt;
    <span class="comment">// The first level of key-ing done in this hash map is the source that
    // dependencies come from, identified by a `SourceId`.
    // The next level is keyed by the name of the package...
    </span>(SourceId, InternedString),
    <span class="comment">// ... and the value here is a list of tuples. The first element of each
    // tuple is a package which has the source/name used to get to this
    // point. The second element of each tuple is the list of locked
    // dependencies that the first element has.
    </span>Vec&lt;(PackageId, Vec&lt;PackageId&gt;)&gt;,
&gt;;

<span class="attribute">#[derive(PartialEq, Eq, Clone, Copy)]
</span><span class="kw">enum </span>Kind {
    Override,
    Locked,
    Normal,
}

<span class="doccomment">/// Argument to `PackageRegistry::patch` which is information about a `[patch]`
/// directive that we found in a lockfile, if present.
</span><span class="kw">pub struct </span>LockedPatchDependency {
    <span class="doccomment">/// The original `Dependency` directive, except &quot;locked&quot; so it&#39;s version
    /// requirement is `=foo` and its `SourceId` has a &quot;precise&quot; listed.
    </span><span class="kw">pub </span>dependency: Dependency,
    <span class="doccomment">/// The `PackageId` that was previously found in a lock file which
    /// `dependency` matches.
    </span><span class="kw">pub </span>package_id: PackageId,
    <span class="doccomment">/// Something only used for backwards compatibility with the v2 lock file
    /// format where `branch=master` is considered the same as `DefaultBranch`.
    /// For more comments on this see the code in `ops/resolve.rs`.
    </span><span class="kw">pub </span>alt_package_id: <span class="prelude-ty">Option</span>&lt;PackageId&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;cfg</span>&gt; PackageRegistry&lt;<span class="lifetime">&#39;cfg</span>&gt; {
    <span class="kw">pub fn </span>new(config: <span class="kw-2">&amp;</span><span class="lifetime">&#39;cfg </span>Config) -&gt; CargoResult&lt;PackageRegistry&lt;<span class="lifetime">&#39;cfg</span>&gt;&gt; {
        <span class="kw">let </span>source_config = SourceConfigMap::new(config)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(PackageRegistry {
            config,
            sources: SourceMap::new(),
            source_ids: HashMap::new(),
            overrides: Vec::new(),
            source_config,
            locked: HashMap::new(),
            yanked_whitelist: HashSet::new(),
            patches: HashMap::new(),
            patches_locked: <span class="bool-val">false</span>,
            patches_available: HashMap::new(),
        })
    }

    <span class="kw">pub fn </span>get(<span class="self">self</span>, package_ids: <span class="kw-2">&amp;</span>[PackageId]) -&gt; CargoResult&lt;PackageSet&lt;<span class="lifetime">&#39;cfg</span>&gt;&gt; {
        <span class="macro">trace!</span>(<span class="string">&quot;getting packages; sources={}&quot;</span>, <span class="self">self</span>.sources.len());
        PackageSet::new(package_ids, <span class="self">self</span>.sources, <span class="self">self</span>.config)
    }

    <span class="kw">fn </span>ensure_loaded(<span class="kw-2">&amp;mut </span><span class="self">self</span>, namespace: SourceId, kind: Kind) -&gt; CargoResult&lt;()&gt; {
        <span class="kw">match </span><span class="self">self</span>.source_ids.get(<span class="kw-2">&amp;</span>namespace) {
            <span class="comment">// We&#39;ve previously loaded this source, and we&#39;ve already locked it,
            // so we&#39;re not allowed to change it even if `namespace` has a
            // slightly different precise version listed.
            </span><span class="prelude-val">Some</span>((<span class="kw">_</span>, Kind::Locked)) =&gt; {
                <span class="macro">debug!</span>(<span class="string">&quot;load/locked   {}&quot;</span>, namespace);
                <span class="kw">return </span><span class="prelude-val">Ok</span>(());
            }

            <span class="comment">// If the previous source was not a precise source, then we can be
            // sure that it&#39;s already been updated if we&#39;ve already loaded it.
            </span><span class="prelude-val">Some</span>((previous, <span class="kw">_</span>)) <span class="kw">if </span>previous.precise().is_none() =&gt; {
                <span class="macro">debug!</span>(<span class="string">&quot;load/precise  {}&quot;</span>, namespace);
                <span class="kw">return </span><span class="prelude-val">Ok</span>(());
            }

            <span class="comment">// If the previous source has the same precise version as we do,
            // then we&#39;re done, otherwise we need to need to move forward
            // updating this source.
            </span><span class="prelude-val">Some</span>((previous, <span class="kw">_</span>)) =&gt; {
                <span class="kw">if </span>previous.precise() == namespace.precise() {
                    <span class="macro">debug!</span>(<span class="string">&quot;load/match    {}&quot;</span>, namespace);
                    <span class="kw">return </span><span class="prelude-val">Ok</span>(());
                }
                <span class="macro">debug!</span>(<span class="string">&quot;load/mismatch {}&quot;</span>, namespace);
            }
            <span class="prelude-val">None </span>=&gt; {
                <span class="macro">debug!</span>(<span class="string">&quot;load/missing  {}&quot;</span>, namespace);
            }
        }

        <span class="self">self</span>.load(namespace, kind)<span class="question-mark">?</span>;

        <span class="comment">// This isn&#39;t strictly necessary since it will be called later.
        // However it improves error messages for sources that issue errors
        // in `block_until_ready` because the callers here have context about
        // which deps are being resolved.
        </span><span class="self">self</span>.block_until_ready()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(())
    }

    <span class="kw">pub fn </span>add_sources(<span class="kw-2">&amp;mut </span><span class="self">self</span>, ids: <span class="kw">impl </span>IntoIterator&lt;Item = SourceId&gt;) -&gt; CargoResult&lt;()&gt; {
        <span class="kw">for </span>id <span class="kw">in </span>ids {
            <span class="self">self</span>.ensure_loaded(id, Kind::Locked)<span class="question-mark">?</span>;
        }
        <span class="prelude-val">Ok</span>(())
    }

    <span class="kw">pub fn </span>add_preloaded(<span class="kw-2">&amp;mut </span><span class="self">self</span>, source: Box&lt;<span class="kw">dyn </span>Source + <span class="lifetime">&#39;cfg</span>&gt;) {
        <span class="self">self</span>.add_source(source, Kind::Locked);
    }

    <span class="kw">fn </span>add_source(<span class="kw-2">&amp;mut </span><span class="self">self</span>, source: Box&lt;<span class="kw">dyn </span>Source + <span class="lifetime">&#39;cfg</span>&gt;, kind: Kind) {
        <span class="kw">let </span>id = source.source_id();
        <span class="self">self</span>.sources.insert(source);
        <span class="self">self</span>.source_ids.insert(id, (id, kind));
    }

    <span class="kw">pub fn </span>add_override(<span class="kw-2">&amp;mut </span><span class="self">self</span>, source: Box&lt;<span class="kw">dyn </span>Source + <span class="lifetime">&#39;cfg</span>&gt;) {
        <span class="self">self</span>.overrides.push(source.source_id());
        <span class="self">self</span>.add_source(source, Kind::Override);
    }

    <span class="kw">pub fn </span>add_to_yanked_whitelist(<span class="kw-2">&amp;mut </span><span class="self">self</span>, iter: <span class="kw">impl </span>Iterator&lt;Item = PackageId&gt;) {
        <span class="kw">let </span>pkgs = iter.collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
        <span class="kw">for </span>(<span class="kw">_</span>, source) <span class="kw">in </span><span class="self">self</span>.sources.sources_mut() {
            source.add_to_yanked_whitelist(<span class="kw-2">&amp;</span>pkgs);
        }
        <span class="self">self</span>.yanked_whitelist.extend(pkgs);
    }

    <span class="doccomment">/// remove all residual state from previous lock files.
    </span><span class="kw">pub fn </span>clear_lock(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="macro">trace!</span>(<span class="string">&quot;clear_lock&quot;</span>);
        <span class="self">self</span>.locked = HashMap::new();
    }

    <span class="kw">pub fn </span>register_lock(<span class="kw-2">&amp;mut </span><span class="self">self</span>, id: PackageId, deps: Vec&lt;PackageId&gt;) {
        <span class="macro">trace!</span>(<span class="string">&quot;register_lock: {}&quot;</span>, id);
        <span class="kw">for </span>dep <span class="kw">in </span>deps.iter() {
            <span class="macro">trace!</span>(<span class="string">&quot;\t-&gt; {}&quot;</span>, dep);
        }
        <span class="kw">let </span>sub_vec = <span class="self">self
            </span>.locked
            .entry((id.source_id(), id.name()))
            .or_insert_with(Vec::new);
        sub_vec.push((id, deps));
    }

    <span class="doccomment">/// Insert a `[patch]` section into this registry.
    ///
    /// This method will insert a `[patch]` section for the `url` specified,
    /// with the given list of dependencies. The `url` specified is the URL of
    /// the source to patch (for example this is `crates-io` in the manifest).
    /// The `deps` is an array of all the entries in the `[patch]` section of
    /// the manifest.
    ///
    /// Here the `deps` will be resolved to a precise version and stored
    /// internally for future calls to `query` below. `deps` should be a tuple
    /// where the first element is the patch definition straight from the
    /// manifest, and the second element is an optional variant where the
    /// patch has been locked. This locked patch is the patch locked to
    /// a specific version found in Cargo.lock. This will be `None` if
    /// `Cargo.lock` doesn&#39;t exist, or the patch did not match any existing
    /// entries in `Cargo.lock`.
    ///
    /// Note that the patch list specified here *will not* be available to
    /// `query` until `lock_patches` is called below, which should be called
    /// once all patches have been added.
    ///
    /// The return value is a `Vec` of patches that should *not* be locked.
    /// This happens when the patch is locked, but the patch has been updated
    /// so the locked value is no longer correct.
    </span><span class="kw">pub fn </span>patch(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        url: <span class="kw-2">&amp;</span>Url,
        deps: <span class="kw-2">&amp;</span>[(<span class="kw-2">&amp;</span>Dependency, <span class="prelude-ty">Option</span>&lt;LockedPatchDependency&gt;)],
    ) -&gt; CargoResult&lt;Vec&lt;(Dependency, PackageId)&gt;&gt; {
        <span class="comment">// NOTE: None of this code is aware of required features. If a patch
        // is missing a required feature, you end up with an &quot;unused patch&quot;
        // warning, which is very hard to understand. Ideally the warning
        // would be tailored to indicate *why* it is unused.
        </span><span class="kw">let </span>canonical = CanonicalUrl::new(url)<span class="question-mark">?</span>;

        <span class="comment">// Return value of patches that shouldn&#39;t be locked.
        </span><span class="kw">let </span><span class="kw-2">mut </span>unlock_patches = Vec::new();

        <span class="comment">// First up we need to actually resolve each `deps` specification to
        // precisely one summary. We&#39;re not using the `query` method below as it
        // internally uses maps we&#39;re building up as part of this method
        // (`patches_available` and `patches`). Instead we&#39;re going straight to
        // the source to load information from it.
        //
        // Remember that each dependency listed in `[patch]` has to resolve to
        // precisely one package, so that&#39;s why we&#39;re just creating a flat list
        // of summaries which should be the same length as `deps` above.

        </span><span class="kw">let </span><span class="kw-2">mut </span>deps_remaining: Vec&lt;<span class="kw">_</span>&gt; = deps.iter().collect();
        <span class="kw">let </span><span class="kw-2">mut </span>unlocked_summaries = Vec::new();
        <span class="kw">while </span>!deps_remaining.is_empty() {
            <span class="kw">let </span><span class="kw-2">mut </span>deps_pending = Vec::new();
            <span class="kw">for </span>dep_remaining <span class="kw">in </span>deps_remaining {
                <span class="kw">let </span>(orig_patch, locked) = dep_remaining;

                <span class="comment">// Use the locked patch if it exists, otherwise use the original.
                </span><span class="kw">let </span>dep = <span class="kw">match </span>locked {
                    <span class="prelude-val">Some</span>(lock) =&gt; <span class="kw-2">&amp;</span>lock.dependency,
                    <span class="prelude-val">None </span>=&gt; <span class="kw-2">*</span>orig_patch,
                };
                <span class="macro">debug!</span>(
                    <span class="string">&quot;registering a patch for `{}` with `{}`&quot;</span>,
                    url,
                    dep.package_name()
                );

                <span class="kw">if </span>dep.features().len() != <span class="number">0 </span>|| !dep.uses_default_features() {
                    <span class="self">self</span>.source_config.config().shell().warn(<span class="macro">format!</span>(
                        <span class="string">&quot;patch for `{}` uses the features mechanism. \
                        default-features and features will not take effect because the patch dependency does not support this mechanism&quot;</span>,
                        dep.package_name()
                    ))<span class="question-mark">?</span>;
                }

                <span class="comment">// Go straight to the source for resolving `dep`. Load it as we
                // normally would and then ask it directly for the list of summaries
                // corresponding to this `dep`.
                </span><span class="self">self</span>.ensure_loaded(dep.source_id(), Kind::Normal)
                    .with_context(|| {
                        <span class="macro">format!</span>(
                            <span class="string">&quot;failed to load source for dependency `{}`&quot;</span>,
                            dep.package_name()
                        )
                    })<span class="question-mark">?</span>;

                <span class="kw">let </span>source = <span class="self">self
                    </span>.sources
                    .get_mut(dep.source_id())
                    .expect(<span class="string">&quot;loaded source not present&quot;</span>);

                <span class="kw">let </span>summaries = <span class="kw">match </span>source.query_vec(dep, QueryKind::Exact)<span class="question-mark">? </span>{
                    Poll::Ready(deps) =&gt; deps,
                    Poll::Pending =&gt; {
                        deps_pending.push(dep_remaining);
                        <span class="kw">continue</span>;
                    }
                };

                <span class="kw">let </span>(summary, should_unlock) =
                    <span class="kw">match </span>summary_for_patch(orig_patch, <span class="kw-2">&amp;</span>locked, summaries, source) {
                        Poll::Ready(x) =&gt; x,
                        Poll::Pending =&gt; {
                            deps_pending.push(dep_remaining);
                            <span class="kw">continue</span>;
                        }
                    }
                    .with_context(|| {
                        <span class="macro">format!</span>(
                            <span class="string">&quot;patch for `{}` in `{}` failed to resolve&quot;</span>,
                            orig_patch.package_name(),
                            url,
                        )
                    })
                    .with_context(|| <span class="macro">format!</span>(<span class="string">&quot;failed to resolve patches for `{}`&quot;</span>, url))<span class="question-mark">?</span>;

                <span class="macro">debug!</span>(
                    <span class="string">&quot;patch summary is {:?} should_unlock={:?}&quot;</span>,
                    summary, should_unlock
                );
                <span class="kw">if let </span><span class="prelude-val">Some</span>(unlock_id) = should_unlock {
                    unlock_patches.push(((<span class="kw-2">*</span>orig_patch).clone(), unlock_id));
                }

                <span class="kw">if </span><span class="kw-2">*</span>summary.package_id().source_id().canonical_url() == canonical {
                    <span class="kw">return </span><span class="prelude-val">Err</span>(<span class="macro">anyhow::anyhow!</span>(
                        <span class="string">&quot;patch for `{}` in `{}` points to the same source, but \
                        patches must point to different sources&quot;</span>,
                        dep.package_name(),
                        url
                    ))
                    .context(<span class="macro">format!</span>(<span class="string">&quot;failed to resolve patches for `{}`&quot;</span>, url));
                }
                unlocked_summaries.push(summary);
            }

            deps_remaining = deps_pending;
            <span class="self">self</span>.block_until_ready()<span class="question-mark">?</span>;
        }

        <span class="kw">let </span><span class="kw-2">mut </span>name_and_version = HashSet::new();
        <span class="kw">for </span>summary <span class="kw">in </span>unlocked_summaries.iter() {
            <span class="kw">let </span>name = summary.package_id().name();
            <span class="kw">let </span>version = summary.package_id().version();
            <span class="kw">if </span>!name_and_version.insert((name, version)) {
                <span class="macro">bail!</span>(
                    <span class="string">&quot;cannot have two `[patch]` entries which both resolve \
                     to `{} v{}`&quot;</span>,
                    name,
                    version
                );
            }
        }

        <span class="comment">// Calculate a list of all patches available for this source which is
        // then used later during calls to `lock` to rewrite summaries to point
        // directly at these patched entries.
        //
        // Note that this is somewhat subtle where the list of `ids` for a
        // canonical URL is extend with possibly two ids per summary. This is done
        // to handle the transition from the v2-&gt;v3 lock file format where in
        // v2 DefeaultBranch was either DefaultBranch or Branch(&quot;master&quot;) for
        // git dependencies. In this case if `summary.package_id()` is
        // Branch(&quot;master&quot;) then alt_package_id will be DefaultBranch. This
        // signifies that there&#39;s a patch available for either of those
        // dependency directives if we see them in the dependency graph.
        //
        // This is a bit complicated and hopefully an edge case we can remove
        // in the future, but for now it hopefully doesn&#39;t cause too much
        // harm...
        </span><span class="kw">let </span><span class="kw-2">mut </span>ids = Vec::new();
        <span class="kw">for </span>(summary, (<span class="kw">_</span>, lock)) <span class="kw">in </span>unlocked_summaries.iter().zip(deps) {
            ids.push(summary.package_id());
            <span class="kw">if let </span><span class="prelude-val">Some</span>(lock) = lock {
                ids.extend(lock.alt_package_id);
            }
        }
        <span class="self">self</span>.patches_available.insert(canonical.clone(), ids);

        <span class="comment">// Note that we do not use `lock` here to lock summaries! That step
        // happens later once `lock_patches` is invoked. In the meantime though
        // we want to fill in the `patches_available` map (later used in the
        // `lock` method) and otherwise store the unlocked summaries in
        // `patches` to get locked in a future call to `lock_patches`.
        </span><span class="self">self</span>.patches.insert(canonical, unlocked_summaries);

        <span class="prelude-val">Ok</span>(unlock_patches)
    }

    <span class="doccomment">/// Lock all patch summaries added via `patch`, making them available to
    /// resolution via `query`.
    ///
    /// This function will internally `lock` each summary added via `patch`
    /// above now that the full set of `patch` packages are known. This&#39;ll allow
    /// us to correctly resolve overridden dependencies between patches
    /// hopefully!
    </span><span class="kw">pub fn </span>lock_patches(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="macro">assert!</span>(!<span class="self">self</span>.patches_locked);
        <span class="kw">for </span>summaries <span class="kw">in </span><span class="self">self</span>.patches.values_mut() {
            <span class="kw">for </span>summary <span class="kw">in </span>summaries {
                <span class="macro">debug!</span>(<span class="string">&quot;locking patch {:?}&quot;</span>, summary);
                <span class="kw-2">*</span>summary = lock(<span class="kw-2">&amp;</span><span class="self">self</span>.locked, <span class="kw-2">&amp;</span><span class="self">self</span>.patches_available, summary.clone());
            }
        }
        <span class="self">self</span>.patches_locked = <span class="bool-val">true</span>;
    }

    <span class="doccomment">/// Gets all patches grouped by the source URLS they are going to patch.
    ///
    /// These patches are mainly collected from [`patch`](Self::patch).
    /// They might not be the same as patches actually used during dependency resolving.
    </span><span class="kw">pub fn </span>patches(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>HashMap&lt;CanonicalUrl, Vec&lt;Summary&gt;&gt; {
        <span class="kw-2">&amp;</span><span class="self">self</span>.patches
    }

    <span class="kw">fn </span>load(<span class="kw-2">&amp;mut </span><span class="self">self</span>, source_id: SourceId, kind: Kind) -&gt; CargoResult&lt;()&gt; {
        <span class="macro">debug!</span>(<span class="string">&quot;loading source {}&quot;</span>, source_id);
        <span class="kw">let </span>source = <span class="self">self
            </span>.source_config
            .load(source_id, <span class="kw-2">&amp;</span><span class="self">self</span>.yanked_whitelist)
            .with_context(|| <span class="macro">format!</span>(<span class="string">&quot;Unable to update {}&quot;</span>, source_id))<span class="question-mark">?</span>;
        <span class="macro">assert_eq!</span>(source.source_id(), source_id);

        <span class="kw">if </span>kind == Kind::Override {
            <span class="self">self</span>.overrides.push(source_id);
        }
        <span class="self">self</span>.add_source(source, kind);

        <span class="comment">// If we have an imprecise version then we don&#39;t know what we&#39;re going
        // to look for, so we always attempt to perform an update here.
        //
        // If we have a precise version, then we&#39;ll update lazily during the
        // querying phase. Note that precise in this case is only
        // `Some(&quot;locked&quot;)` as other `Some` values indicate a `cargo update
        // --precise` request
        </span><span class="kw">if </span>source_id.precise() != <span class="prelude-val">Some</span>(<span class="string">&quot;locked&quot;</span>) {
            <span class="self">self</span>.sources.get_mut(source_id).unwrap().invalidate_cache();
        } <span class="kw">else </span>{
            <span class="macro">debug!</span>(<span class="string">&quot;skipping update due to locked registry&quot;</span>);
        }
        <span class="prelude-val">Ok</span>(())
    }

    <span class="kw">fn </span>query_overrides(<span class="kw-2">&amp;mut </span><span class="self">self</span>, dep: <span class="kw-2">&amp;</span>Dependency) -&gt; Poll&lt;CargoResult&lt;<span class="prelude-ty">Option</span>&lt;Summary&gt;&gt;&gt; {
        <span class="kw">for </span><span class="kw-2">&amp;</span>s <span class="kw">in </span><span class="self">self</span>.overrides.iter() {
            <span class="kw">let </span>src = <span class="self">self</span>.sources.get_mut(s).unwrap();
            <span class="kw">let </span>dep = Dependency::new_override(dep.package_name(), s);
            <span class="kw">let </span><span class="kw-2">mut </span>results = <span class="macro">ready!</span>(src.query_vec(<span class="kw-2">&amp;</span>dep, QueryKind::Exact))<span class="question-mark">?</span>;
            <span class="kw">if </span>!results.is_empty() {
                <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(results.remove(<span class="number">0</span>))));
            }
        }
        Poll::Ready(<span class="prelude-val">Ok</span>(<span class="prelude-val">None</span>))
    }

    <span class="doccomment">/// This function is used to transform a summary to another locked summary
    /// if possible. This is where the concept of a lock file comes into play.
    ///
    /// If a summary points at a package ID which was previously locked, then we
    /// override the summary&#39;s ID itself, as well as all dependencies, to be
    /// rewritten to the locked versions. This will transform the summary&#39;s
    /// source to a precise source (listed in the locked version) as well as
    /// transforming all of the dependencies from range requirements on
    /// imprecise sources to exact requirements on precise sources.
    ///
    /// If a summary does not point at a package ID which was previously locked,
    /// or if any dependencies were added and don&#39;t have a previously listed
    /// version, we still want to avoid updating as many dependencies as
    /// possible to keep the graph stable. In this case we map all of the
    /// summary&#39;s dependencies to be rewritten to a locked version wherever
    /// possible. If we&#39;re unable to map a dependency though, we just pass it on
    /// through.
    </span><span class="kw">pub fn </span>lock(<span class="kw-2">&amp;</span><span class="self">self</span>, summary: Summary) -&gt; Summary {
        <span class="macro">assert!</span>(<span class="self">self</span>.patches_locked);
        lock(<span class="kw-2">&amp;</span><span class="self">self</span>.locked, <span class="kw-2">&amp;</span><span class="self">self</span>.patches_available, summary)
    }

    <span class="kw">fn </span>warn_bad_override(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        override_summary: <span class="kw-2">&amp;</span>Summary,
        real_summary: <span class="kw-2">&amp;</span>Summary,
    ) -&gt; CargoResult&lt;()&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>real_deps = real_summary.dependencies().iter().collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();

        <span class="kw">let </span>boilerplate = <span class="string">&quot;\
This is currently allowed but is known to produce buggy behavior with spurious
recompiles and changes to the crate graph. Path overrides unfortunately were
never intended to support this feature, so for now this message is just a
warning. In the future, however, this message will become a hard error.

To change the dependency graph via an override it&#39;s recommended to use the
`[patch]` feature of Cargo instead of the path override feature. This is
documented online at the url below for more information.

https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html
&quot;</span>;

        <span class="kw">for </span>dep <span class="kw">in </span>override_summary.dependencies() {
            <span class="kw">if let </span><span class="prelude-val">Some</span>(i) = real_deps.iter().position(|d| dep == <span class="kw-2">*</span>d) {
                real_deps.remove(i);
                <span class="kw">continue</span>;
            }
            <span class="kw">let </span>msg = <span class="macro">format!</span>(
                <span class="string">&quot;path override for crate `{}` has altered the original list of\n\
                 dependencies; the dependency on `{}` was either added or\n\
                 modified to not match the previously resolved version\n\n\
                 {}&quot;</span>,
                override_summary.package_id().name(),
                dep.package_name(),
                boilerplate
            );
            <span class="self">self</span>.source_config.config().shell().warn(<span class="kw-2">&amp;</span>msg)<span class="question-mark">?</span>;
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }

        <span class="kw">if let </span><span class="prelude-val">Some</span>(dep) = real_deps.get(<span class="number">0</span>) {
            <span class="kw">let </span>msg = <span class="macro">format!</span>(
                <span class="string">&quot;path override for crate `{}` has altered the original list of\n\
                 dependencies; the dependency on `{}` was removed\n\n\
                 {}&quot;</span>,
                override_summary.package_id().name(),
                dep.package_name(),
                boilerplate
            );
            <span class="self">self</span>.source_config.config().shell().warn(<span class="kw-2">&amp;</span>msg)<span class="question-mark">?</span>;
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }

        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;cfg</span>&gt; Registry <span class="kw">for </span>PackageRegistry&lt;<span class="lifetime">&#39;cfg</span>&gt; {
    <span class="kw">fn </span>query(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        dep: <span class="kw-2">&amp;</span>Dependency,
        kind: QueryKind,
        f: <span class="kw-2">&amp;mut </span><span class="kw">dyn </span>FnMut(Summary),
    ) -&gt; Poll&lt;CargoResult&lt;()&gt;&gt; {
        <span class="macro">assert!</span>(<span class="self">self</span>.patches_locked);
        <span class="kw">let </span>(override_summary, n, to_warn) = {
            <span class="comment">// Look for an override and get ready to query the real source.
            </span><span class="kw">let </span>override_summary = <span class="macro">ready!</span>(<span class="self">self</span>.query_overrides(dep))<span class="question-mark">?</span>;

            <span class="comment">// Next up on our list of candidates is to check the `[patch]`
            // section of the manifest. Here we look through all patches
            // relevant to the source that `dep` points to, and then we match
            // name/version. Note that we don&#39;t use `dep.matches(..)` because
            // the patches, by definition, come from a different source.
            // This means that `dep.matches(..)` will always return false, when
            // what we really care about is the name/version match.
            </span><span class="kw">let </span><span class="kw-2">mut </span>patches = Vec::&lt;Summary&gt;::new();
            <span class="kw">if let </span><span class="prelude-val">Some</span>(extra) = <span class="self">self</span>.patches.get(dep.source_id().canonical_url()) {
                patches.extend(
                    extra
                        .iter()
                        .filter(|s| dep.matches_ignoring_source(s.package_id()))
                        .cloned(),
                );
            }

            <span class="comment">// A crucial feature of the `[patch]` feature is that we *don&#39;t*
            // query the actual registry if we have a &quot;locked&quot; dependency. A
            // locked dep basically just means a version constraint of `=a.b.c`,
            // and because patches take priority over the actual source then if
            // we have a candidate we&#39;re done.
            </span><span class="kw">if </span>patches.len() == <span class="number">1 </span>&amp;&amp; dep.is_locked() {
                <span class="kw">let </span>patch = patches.remove(<span class="number">0</span>);
                <span class="kw">match </span>override_summary {
                    <span class="prelude-val">Some</span>(summary) =&gt; (summary, <span class="number">1</span>, <span class="prelude-val">Some</span>(patch)),
                    <span class="prelude-val">None </span>=&gt; {
                        f(patch);
                        <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Ok</span>(()));
                    }
                }
            } <span class="kw">else </span>{
                <span class="kw">if </span>!patches.is_empty() {
                    <span class="macro">debug!</span>(
                        <span class="string">&quot;found {} patches with an unlocked dep on `{}` at {} \
                         with `{}`, \
                         looking at sources&quot;</span>,
                        patches.len(),
                        dep.package_name(),
                        dep.source_id(),
                        dep.version_req()
                    );
                }

                <span class="comment">// Ensure the requested source_id is loaded
                </span><span class="self">self</span>.ensure_loaded(dep.source_id(), Kind::Normal)
                    .with_context(|| {
                        <span class="macro">format!</span>(
                            <span class="string">&quot;failed to load source for dependency `{}`&quot;</span>,
                            dep.package_name()
                        )
                    })<span class="question-mark">?</span>;

                <span class="kw">let </span>source = <span class="self">self</span>.sources.get_mut(dep.source_id());
                <span class="kw">match </span>(override_summary, source) {
                    (<span class="prelude-val">Some</span>(<span class="kw">_</span>), <span class="prelude-val">None</span>) =&gt; {
                        <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Err</span>(<span class="macro">anyhow::anyhow!</span>(<span class="string">&quot;override found but no real ones&quot;</span>)))
                    }
                    (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>) =&gt; <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Ok</span>(())),

                    <span class="comment">// If we don&#39;t have an override then we just ship
                    // everything upstairs after locking the summary
                    </span>(<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(source)) =&gt; {
                        <span class="kw">for </span>patch <span class="kw">in </span>patches.iter() {
                            f(patch.clone());
                        }

                        <span class="comment">// Our sources shouldn&#39;t ever come back to us with two
                        // summaries that have the same version. We could,
                        // however, have an `[patch]` section which is in use
                        // to override a version in the registry. This means
                        // that if our `summary` in this loop has the same
                        // version as something in `patches` that we&#39;ve
                        // already selected, then we skip this `summary`.
                        </span><span class="kw">let </span>locked = <span class="kw-2">&amp;</span><span class="self">self</span>.locked;
                        <span class="kw">let </span>all_patches = <span class="kw-2">&amp;</span><span class="self">self</span>.patches_available;
                        <span class="kw">let </span>callback = <span class="kw-2">&amp;mut </span>|summary: Summary| {
                            <span class="kw">for </span>patch <span class="kw">in </span>patches.iter() {
                                <span class="kw">let </span>patch = patch.package_id().version();
                                <span class="kw">if </span>summary.package_id().version() == patch {
                                    <span class="kw">return</span>;
                                }
                            }
                            f(lock(locked, all_patches, summary))
                        };
                        <span class="kw">return </span>source.query(dep, kind, callback);
                    }

                    <span class="comment">// If we have an override summary then we query the source
                    // to sanity check its results. We don&#39;t actually use any of
                    // the summaries it gives us though.
                    </span>(<span class="prelude-val">Some</span>(override_summary), <span class="prelude-val">Some</span>(source)) =&gt; {
                        <span class="kw">if </span>!patches.is_empty() {
                            <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Err</span>(<span class="macro">anyhow::anyhow!</span>(
                                <span class="string">&quot;found patches and a path override&quot;
                            </span>)));
                        }
                        <span class="kw">let </span><span class="kw-2">mut </span>n = <span class="number">0</span>;
                        <span class="kw">let </span><span class="kw-2">mut </span>to_warn = <span class="prelude-val">None</span>;
                        {
                            <span class="kw">let </span>callback = <span class="kw-2">&amp;mut </span>|summary| {
                                n += <span class="number">1</span>;
                                to_warn = <span class="prelude-val">Some</span>(summary);
                            };
                            <span class="kw">let </span>pend = source.query(dep, kind, callback);
                            <span class="kw">if </span>pend.is_pending() {
                                <span class="kw">return </span>Poll::Pending;
                            }
                        }
                        (override_summary, n, to_warn)
                    }
                }
            }
        };

        <span class="kw">if </span>n &gt; <span class="number">1 </span>{
            <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Err</span>(<span class="macro">anyhow::anyhow!</span>(
                <span class="string">&quot;found an override with a non-locked list&quot;
            </span>)));
        } <span class="kw">else if let </span><span class="prelude-val">Some</span>(summary) = to_warn {
            <span class="self">self</span>.warn_bad_override(<span class="kw-2">&amp;</span>override_summary, <span class="kw-2">&amp;</span>summary)<span class="question-mark">?</span>;
        }
        f(<span class="self">self</span>.lock(override_summary));
        Poll::Ready(<span class="prelude-val">Ok</span>(()))
    }

    <span class="kw">fn </span>describe_source(<span class="kw-2">&amp;</span><span class="self">self</span>, id: SourceId) -&gt; String {
        <span class="kw">match </span><span class="self">self</span>.sources.get(id) {
            <span class="prelude-val">Some</span>(src) =&gt; src.describe(),
            <span class="prelude-val">None </span>=&gt; id.to_string(),
        }
    }

    <span class="kw">fn </span>is_replaced(<span class="kw-2">&amp;</span><span class="self">self</span>, id: SourceId) -&gt; bool {
        <span class="kw">match </span><span class="self">self</span>.sources.get(id) {
            <span class="prelude-val">Some</span>(src) =&gt; src.is_replaced(),
            <span class="prelude-val">None </span>=&gt; <span class="bool-val">false</span>,
        }
    }

    <span class="kw">fn </span>block_until_ready(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; CargoResult&lt;()&gt; {
        <span class="kw">for </span>(source_id, source) <span class="kw">in </span><span class="self">self</span>.sources.sources_mut() {
            source
                .block_until_ready()
                .with_context(|| <span class="macro">format!</span>(<span class="string">&quot;Unable to update {}&quot;</span>, source_id))<span class="question-mark">?</span>;
        }
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">fn </span>lock(
    locked: <span class="kw-2">&amp;</span>LockedMap,
    patches: <span class="kw-2">&amp;</span>HashMap&lt;CanonicalUrl, Vec&lt;PackageId&gt;&gt;,
    summary: Summary,
) -&gt; Summary {
    <span class="kw">let </span>pair = locked
        .get(<span class="kw-2">&amp;</span>(summary.source_id(), summary.name()))
        .and_then(|vec| vec.iter().find(|&amp;&amp;(id, <span class="kw">_</span>)| id == summary.package_id()));

    <span class="macro">trace!</span>(<span class="string">&quot;locking summary of {}&quot;</span>, summary.package_id());

    <span class="comment">// Lock the summary&#39;s ID if possible
    </span><span class="kw">let </span>summary = <span class="kw">match </span>pair {
        <span class="prelude-val">Some</span>((precise, <span class="kw">_</span>)) =&gt; summary.override_id(<span class="kw-2">*</span>precise),
        <span class="prelude-val">None </span>=&gt; summary,
    };
    summary.map_dependencies(|dep| {
        <span class="macro">trace!</span>(
            <span class="string">&quot;\t{}/{}/{}&quot;</span>,
            dep.package_name(),
            dep.version_req(),
            dep.source_id()
        );

        <span class="comment">// If we&#39;ve got a known set of overrides for this summary, then
        // one of a few cases can arise:
        //
        // 1. We have a lock entry for this dependency from the same
        //    source as it&#39;s listed as coming from. In this case we make
        //    sure to lock to precisely the given package ID.
        //
        // 2. We have a lock entry for this dependency, but it&#39;s from a
        //    different source than what&#39;s listed, or the version
        //    requirement has changed. In this case we must discard the
        //    locked version because the dependency needs to be
        //    re-resolved.
        //
        // 3. We have a lock entry for this dependency, but it&#39;s from a
        //    different source than what&#39;s listed. This lock though happens
        //    through `[patch]`, so we want to preserve it.
        //
        // 4. We don&#39;t have a lock entry for this dependency, in which
        //    case it was likely an optional dependency which wasn&#39;t
        //    included previously so we just pass it through anyway.
        //
        // Cases 1/2 are handled by `matches_id`, case 3 is handled specially,
        // and case 4 is handled by falling through to the logic below.
        </span><span class="kw">if let </span><span class="prelude-val">Some</span>((<span class="kw">_</span>, locked_deps)) = pair {
            <span class="kw">let </span>locked = locked_deps.iter().find(|&amp;&amp;id| {
                <span class="comment">// If the dependency matches the package id exactly then we&#39;ve
                // found a match, this is the id the dependency was previously
                // locked to.
                </span><span class="kw">if </span>dep.matches_id(id) {
                    <span class="kw">return </span><span class="bool-val">true</span>;
                }

                <span class="comment">// If the name/version doesn&#39;t match, then we definitely don&#39;t
                // have a match whatsoever. Otherwise we need to check
                // `[patch]`...
                </span><span class="kw">if </span>!dep.matches_ignoring_source(id) {
                    <span class="kw">return </span><span class="bool-val">false</span>;
                }

                <span class="comment">// ... so here we look up the dependency url in the patches
                // map, and we see if `id` is contained in the list of patches
                // for that url. If it is then this lock is still valid,
                // otherwise the lock is no longer valid.
                </span><span class="kw">match </span>patches.get(dep.source_id().canonical_url()) {
                    <span class="prelude-val">Some</span>(list) =&gt; list.contains(<span class="kw-2">&amp;</span>id),
                    <span class="prelude-val">None </span>=&gt; <span class="bool-val">false</span>,
                }
            });

            <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>locked) = locked {
                <span class="macro">trace!</span>(<span class="string">&quot;\tfirst hit on {}&quot;</span>, locked);
                <span class="kw">let </span><span class="kw-2">mut </span>dep = dep;

                <span class="comment">// If we found a locked version where the sources match, then
                // we can `lock_to` to get an exact lock on this dependency.
                // Otherwise we got a lock via `[patch]` so we only lock the
                // version requirement, not the source.
                </span><span class="kw">if </span>locked.source_id() == dep.source_id() {
                    dep.lock_to(locked);
                } <span class="kw">else </span>{
                    dep.lock_version(locked.version());
                }
                <span class="kw">return </span>dep;
            }
        }

        <span class="comment">// If this dependency did not have a locked version, then we query
        // all known locked packages to see if they match this dependency.
        // If anything does then we lock it to that and move on.
        </span><span class="kw">let </span>v = locked
            .get(<span class="kw-2">&amp;</span>(dep.source_id(), dep.package_name()))
            .and_then(|vec| vec.iter().find(|&amp;&amp;(id, <span class="kw">_</span>)| dep.matches_id(id)));
        <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>(id, <span class="kw">_</span>)) = v {
            <span class="macro">trace!</span>(<span class="string">&quot;\tsecond hit on {}&quot;</span>, id);
            <span class="kw">let </span><span class="kw-2">mut </span>dep = dep;
            dep.lock_to(id);
            <span class="kw">return </span>dep;
        }

        <span class="macro">trace!</span>(<span class="string">&quot;\tnope, unlocked&quot;</span>);
        dep
    })
}

<span class="doccomment">/// This is a helper for selecting the summary, or generating a helpful error message.
</span><span class="kw">fn </span>summary_for_patch(
    orig_patch: <span class="kw-2">&amp;</span>Dependency,
    locked: <span class="kw-2">&amp;</span><span class="prelude-ty">Option</span>&lt;LockedPatchDependency&gt;,
    <span class="kw-2">mut </span>summaries: Vec&lt;Summary&gt;,
    source: <span class="kw-2">&amp;mut </span><span class="kw">dyn </span>Source,
) -&gt; Poll&lt;CargoResult&lt;(Summary, <span class="prelude-ty">Option</span>&lt;PackageId&gt;)&gt;&gt; {
    <span class="kw">if </span>summaries.len() == <span class="number">1 </span>{
        <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Ok</span>((summaries.pop().unwrap(), <span class="prelude-val">None</span>)));
    }
    <span class="kw">if </span>summaries.len() &gt; <span class="number">1 </span>{
        <span class="comment">// TODO: In the future, it might be nice to add all of these
        // candidates so that version selection would just pick the
        // appropriate one. However, as this is currently structured, if we
        // added these all as patches, the unselected versions would end up in
        // the &quot;unused patch&quot; listing, and trigger a warning. It might take a
        // fair bit of restructuring to make that work cleanly, and there
        // isn&#39;t any demand at this time to support that.
        </span><span class="kw">let </span><span class="kw-2">mut </span>vers: Vec&lt;<span class="kw">_</span>&gt; = summaries.iter().map(|summary| summary.version()).collect();
        vers.sort();
        <span class="kw">let </span>versions: Vec&lt;<span class="kw">_</span>&gt; = vers.into_iter().map(|v| v.to_string()).collect();
        <span class="kw">return </span>Poll::Ready(<span class="prelude-val">Err</span>(<span class="macro">anyhow::anyhow!</span>(
            <span class="string">&quot;patch for `{}` in `{}` resolved to more than one candidate\n\
            Found versions: {}\n\
            Update the patch definition to select only one package.\n\
            For example, add an `=` version requirement to the patch definition, \
            such as `version = \&quot;={}\&quot;`.&quot;</span>,
            orig_patch.package_name(),
            orig_patch.source_id(),
            versions.join(<span class="string">&quot;, &quot;</span>),
            versions.last().unwrap()
        )));
    }
    <span class="macro">assert!</span>(summaries.is_empty());
    <span class="comment">// No summaries found, try to help the user figure out what is wrong.
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(locked) = locked {
        <span class="comment">// Since the locked patch did not match anything, try the unlocked one.
        </span><span class="kw">let </span>orig_matches =
            <span class="macro">ready!</span>(source.query_vec(orig_patch, QueryKind::Exact)).unwrap_or_else(|e| {
                <span class="macro">log::warn!</span>(
                    <span class="string">&quot;could not determine unlocked summaries for dep {:?}: {:?}&quot;</span>,
                    orig_patch,
                    e
                );
                Vec::new()
            });

        <span class="kw">let </span>summary = <span class="macro">ready!</span>(summary_for_patch(orig_patch, <span class="kw-2">&amp;</span><span class="prelude-val">None</span>, orig_matches, source))<span class="question-mark">?</span>;

        <span class="comment">// The unlocked version found a match. This returns a value to
        // indicate that this entry should be unlocked.
        </span><span class="kw">return </span>Poll::Ready(<span class="prelude-val">Ok</span>((summary.<span class="number">0</span>, <span class="prelude-val">Some</span>(locked.package_id))));
    }
    <span class="comment">// Try checking if there are *any* packages that match this by name.
    </span><span class="kw">let </span>name_only_dep = Dependency::new_override(orig_patch.package_name(), orig_patch.source_id());

    <span class="kw">let </span>name_summaries =
        <span class="macro">ready!</span>(source.query_vec(<span class="kw-2">&amp;</span>name_only_dep, QueryKind::Exact)).unwrap_or_else(|e| {
            <span class="macro">log::warn!</span>(
                <span class="string">&quot;failed to do name-only summary query for {:?}: {:?}&quot;</span>,
                name_only_dep,
                e
            );
            Vec::new()
        });
    <span class="kw">let </span><span class="kw-2">mut </span>vers = name_summaries
        .iter()
        .map(|summary| summary.version())
        .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;();
    <span class="kw">let </span>found = <span class="kw">match </span>vers.len() {
        <span class="number">0 </span>=&gt; <span class="macro">format!</span>(<span class="string">&quot;&quot;</span>),
        <span class="number">1 </span>=&gt; <span class="macro">format!</span>(<span class="string">&quot;version `{}`&quot;</span>, vers[<span class="number">0</span>]),
        <span class="kw">_ </span>=&gt; {
            vers.sort();
            <span class="kw">let </span>strs: Vec&lt;<span class="kw">_</span>&gt; = vers.into_iter().map(|v| v.to_string()).collect();
            <span class="macro">format!</span>(<span class="string">&quot;versions `{}`&quot;</span>, strs.join(<span class="string">&quot;, &quot;</span>))
        }
    };
    Poll::Ready(<span class="prelude-val">Err</span>(<span class="kw">if </span>found.is_empty() {
        <span class="macro">anyhow::anyhow!</span>(
            <span class="string">&quot;The patch location `{}` does not appear to contain any packages \
            matching the name `{}`.&quot;</span>,
            orig_patch.source_id(),
            orig_patch.package_name()
        )
    } <span class="kw">else </span>{
        <span class="macro">anyhow::anyhow!</span>(
            <span class="string">&quot;The patch location `{}` contains a `{}` package with {}, but the patch \
            definition requires `{}`.\n\
            Check that the version in the patch location is what you expect, \
            and update the patch definition to match.&quot;</span>,
            orig_patch.source_id(),
            orig_patch.package_name(),
            found,
            orig_patch.version_req()
        )
    }))
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="cargo" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>